<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>何恒甫的博客</title>
  
  <subtitle> </subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-11T14:37:32.103Z</updated>
  <id>http://example.com/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/08/11/hello-world/"/>
    <id>http://example.com/2022/08/11/hello-world/</id>
    <published>2022-08-11T15:28:13.151Z</published>
    <updated>2022-08-11T14:37:32.103Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>git本地代码推送到gitee步骤</title>
    <link href="http://example.com/2022/08/11/git%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E6%8E%A8%E9%80%81%E5%88%B0gitee%E6%AD%A5%E9%AA%A4/"/>
    <id>http://example.com/2022/08/11/git%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E6%8E%A8%E9%80%81%E5%88%B0gitee%E6%AD%A5%E9%AA%A4/</id>
    <published>2022-08-11T14:30:43.162Z</published>
    <updated>2022-08-09T14:31:47.349Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>本地先初始化git仓库</p><p><code>git init</code></p></li><li><p>gitee创建仓库,并记录下仓库地址</p></li><li><p>使本地仓库与gitee仓库关联</p><p><code>git remote add origin + 仓库地址</code></p></li><li><p>第一次关联可能会需要输入gitee账号密码</p></li><li><p>拉取gitee仓库到本地</p><p><code>git pull --rebase origin master</code></p></li><li><p>添加新增文件或修改的内容</p><p><code>git add .</code></p></li><li><p>添加版本</p><p><code>git commit -m &quot;注释内容&quot;</code></p></li><li><p>推送到gitee</p><p><code>git push origin master</code></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;本地先初始化git仓库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git init&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;gitee创建仓库,并记录下仓库地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使本地仓库与gitee仓库关联&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git r</summary>
      
    
    
    
    <category term="git" scheme="http://example.com/categories/git/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>ETAS生成RTE时需使用的命令</title>
    <link href="http://example.com/2022/08/11/ETAS%E7%94%9F%E6%88%90RTE%E6%97%B6%E9%9C%80%E4%BD%BF%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/08/11/ETAS%E7%94%9F%E6%88%90RTE%E6%97%B6%E9%9C%80%E4%BD%BF%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/</id>
    <published>2022-08-11T14:30:43.158Z</published>
    <updated>2022-08-07T13:29:57.608Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ETAS生成RTE时需使用的命令"><a href="#ETAS生成RTE时需使用的命令" class="headerlink" title="ETAS生成RTE时需使用的命令"></a>ETAS生成RTE时需使用的命令</h3><p>-nts -ur=2 –os-define-osenv=RTAOS40 –exclusive-area-optimization=disable –os-output-param=changed –use-partition-sections=on –client-server-global-optimization=off –deviate-bsw-any-partition=1 –deviate-split-swci-support=1 –samples=memmap </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;ETAS生成RTE时需使用的命令&quot;&gt;&lt;a href=&quot;#ETAS生成RTE时需使用的命令&quot; class=&quot;headerlink&quot; title=&quot;ETAS生成RTE时需使用的命令&quot;&gt;&lt;/a&gt;ETAS生成RTE时需使用的命令&lt;/h3&gt;&lt;p&gt;-nts -ur=2 –os</summary>
      
    
    
    
    <category term="ETAS" scheme="http://example.com/categories/ETAS/"/>
    
    
    <category term="ETAS" scheme="http://example.com/tags/ETAS/"/>
    
  </entry>
  
  <entry>
    <title>CRC8的校验原理及代码实现</title>
    <link href="http://example.com/2022/08/11/CRC8%E7%9A%84%E6%A0%A1%E9%AA%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/08/11/CRC8%E7%9A%84%E6%A0%A1%E9%AA%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-08-11T14:30:43.152Z</published>
    <updated>2022-08-07T11:18:06.868Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CRC算法简介"><a href="#CRC算法简介" class="headerlink" title="CRC算法简介"></a>CRC算法简介</h3><p>循环冗余校验（Cyclic Redundancy Check， CRC）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。</p><h3 id="CRC参数模型"><a href="#CRC参数模型" class="headerlink" title="CRC参数模型"></a>CRC参数模型</h3><p>CRC参数模型应该包含以下信息：WIDTH，POLY，INIT，REFIN，REFOUT，XOROUT</p><pre class=" language-bash"><code class="language-bash">WIDTH：宽度，即生成的CRC数据位宽，如CRC8，生成的CRC为8位POLY：十六进制多项式，省略最高位1，如 x8 + x2 + x + 1，二进制为 1 0000 0111，省略最高位1，转换为十六进制为0x07。INIT：CRC初始值，和WIDTH位宽一致。REFIN：true或false，在进行计算之前，原始数据是否翻转，如原始数据：0x34 <span class="token operator">=</span> 0011 0100，如果REFIN为true，进行翻转之后为 0010 1100 <span class="token operator">=</span> 0x2cREFOUT：true或false，运算完成之后，得到的CRC值是否进行翻转，如计算得到的CRC值：0x97 <span class="token operator">=</span> 1001 0111，如果REFOUT为true，进行翻转之后为 1110 1001 <span class="token operator">=</span> 0xE9。XOROUT：计算结果与此参数进行异或运算后得到最终的CRC值，和WIDTH位宽一致。</code></pre><p><strong>通常如果只给了一个多项式，其他的没有说明则：INIT=0x00，REFIN=false，REFOUT=false，XOROUT=0x00。</strong></p><h3 id="CRC计算步骤"><a href="#CRC计算步骤" class="headerlink" title="CRC计算步骤"></a>CRC计算步骤</h3><h4 id="计算方式一"><a href="#计算方式一" class="headerlink" title="计算方式一"></a>计算方式一</h4><pre class=" language-bash"><code class="language-bash">POLY <span class="token operator">=</span> 0x31 <span class="token operator">=</span> 0011 0001<span class="token punctuation">(</span>最高位1已经省略<span class="token punctuation">)</span>INIT <span class="token operator">=</span> 0x00XOROUT <span class="token operator">=</span> 0x00REFIN <span class="token operator">=</span> TRUEREFOUT <span class="token operator">=</span> TRUE</code></pre><pre class=" language-bash"><code class="language-bash">1. 原始数据 <span class="token operator">=</span> 0x34 <span class="token operator">=</span> 0011 0100，多项式 <span class="token operator">=</span> 0x31 <span class="token operator">=</span> 1 0011 00012. INIT <span class="token operator">=</span> 0x00，原始数据高8位和初始值进行异或运算保持不变3. REFIN为TRUE，需要先对原始数据进行翻转： 0011 0100 翻转后得到 0010 11004. 原始数据左移8位，即后面补8个0：0010 1100 0000 00005. 把处理之后的数据和多项式进行模2除法，求得余数6. 原始数据： 0010 1100 0000 0000,与多项式进行计算是从最高位为1的开始,所以实际需要参与运算的数据为 10 1100 0000 00007. 多项式：1 0011 00018. 模2除法<span class="token punctuation">(</span>余数其实是异或运算,只要被除数首位非0,商就是1<span class="token punctuation">)</span>取余数低8位： 1111 10119. 与XOROUT进行异或， 1111 1011 xor 0000 0000 <span class="token operator">=</span> 1111 1011 10. 因为REFOUT为TRUE，对结果进行翻转得到最终的CRC8值： 1101 1111 <span class="token operator">=</span> 0xDF11. 数据拼接CRC得到 0011 0100 1101 1111 <span class="token operator">=</span> 34DF，相当于原始数据左移8位或上余数。</code></pre><h4 id="计算方式二"><a href="#计算方式二" class="headerlink" title="计算方式二"></a>计算方式二</h4><pre class=" language-bash"><code class="language-bash">POLY <span class="token operator">=</span> 0x31 <span class="token operator">=</span> 0011 0001<span class="token punctuation">(</span>最高位1已经省略<span class="token punctuation">)</span>INIT <span class="token operator">=</span> 0x00XOROUT <span class="token operator">=</span> 0x00REFIN <span class="token operator">=</span> FALSEREFOUT <span class="token operator">=</span> FALSE</code></pre><pre class=" language-bash"><code class="language-bash">1. 原始数据 <span class="token operator">=</span> 0x34 <span class="token operator">=</span> 0011 0100，多项式 <span class="token operator">=</span> 0x31 <span class="token operator">=</span> 0011 00012. 原始数据的二进制为 0011 01003. 原始数据移位到最高位的值是1,即 1101 00004. 原始数据再左移一位，因为左移出去的最高位是1,下一步需要与多项式异或运算,左移以后右边补0,即 1010 00005. 多项式为 0011 00016. 异或的结果为 1001 00017. 异或的结果再次左移一位,因为左移出去的最高位是1,下一步需要与多项式异或运算,左移以后右边补0,即 0010 0010    8. 多项式为 0011 00019. 异或的结果为 0001 0011    10. 异或的结果再次左移一位,因为左移出去的最高位是0,不需要与多项式运算,左移以后右边补0,即 0010 0110    11. 再次左移一位,因为左移出去的最高位是0,不需要与多项式运算,左移以后右边补0,即 0100 110012. 再次左移一位,因为左移出去的最高位是0,不需要与多项式运算,左移以后右边补0,即 1001 100013. 再次左移一位,因为左移出去的最高位是1,下一步需要与多项式异或运算,左移以后右边补0,即 0011 000014. 多项式为 0011 000115. 异或的结果为 0000 0001</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="直接运算方式求CRC"><a href="#直接运算方式求CRC" class="headerlink" title="直接运算方式求CRC"></a>直接运算方式求CRC</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#define CRC_ZERO_U                  (0U)</span><span class="token comment" spellcheck="true">#define CRC_BYTELENGTH_U             (8U)</span><span class="token comment" spellcheck="true">#define CRC_CRC8_MSB                ((uint8)0x80)</span><span class="token comment" spellcheck="true">#define CRC_ONE_U                   (1U)</span>static uint8 Crc_lCommonCalculateCRC8Runtime<span class="token punctuation">(</span>  const uint8* const Crc_DataPtr,  const uint32 Crc_Length,  const uint8 Crc_StartValue8,  const uint8 Polynomial_8bit<span class="token punctuation">)</span>｛  uint32 LoopCounter<span class="token punctuation">;</span>  uint8 MessageBit<span class="token punctuation">;</span>  uint8 StartValue8 <span class="token operator">=</span> Crc_StartValue8<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>LoopCounter <span class="token operator">=</span> CRC_ZERO_U<span class="token punctuation">;</span> LoopCounter <span class="token operator">&lt;</span> Crc_Length<span class="token punctuation">;</span>       LoopCounter++<span class="token punctuation">)</span>  ｛    StartValue8 ^<span class="token operator">=</span> Crc_DataPtr<span class="token punctuation">[</span>LoopCounter<span class="token punctuation">]</span><span class="token punctuation">;</span>    for<span class="token punctuation">(</span>MessageBit <span class="token operator">=</span> CRC_BYTELENGTH_U<span class="token punctuation">;</span> MessageBit <span class="token operator">></span> CRC_ZERO_U<span class="token punctuation">;</span>        MessageBit--<span class="token punctuation">)</span>   ｛      <span class="token keyword">if</span><span class="token variable"><span class="token punctuation">((</span> StartValue8 <span class="token operator">&amp;</span> CRC_CRC8_MSB <span class="token punctuation">)</span> <span class="token operator">==</span> CRC_CRC8_MSB<span class="token punctuation">)</span>      ｛        StartValue8 <span class="token operator">=</span><span class="token punctuation">((</span>uint8<span class="token punctuation">)</span><span class="token punctuation">((</span>uint8<span class="token punctuation">)</span>StartValue8 <span class="token operator">&lt;&lt;</span> CRC_ONE_U<span class="token punctuation">))</span></span> ^ Polynomial_8bit<span class="token punctuation">;</span>      ｝      <span class="token keyword">else</span>     ｛        StartValue8 <span class="token operator">=</span><span class="token punctuation">(</span>uint8<span class="token punctuation">)</span><span class="token punctuation">((</span>uint8<span class="token punctuation">)</span>StartValue8 <span class="token operator">&lt;&lt;</span> CRC_ONE_U<span class="token punctuation">)</span><span class="token punctuation">;</span>      ｝    ｝  ｝  <span class="token keyword">return</span> StartValue8<span class="token punctuation">;</span>｝</code></pre><h4 id="查表方式求CRC"><a href="#查表方式求CRC" class="headerlink" title="查表方式求CRC"></a>查表方式求CRC</h4><p>查表的目的是节省MCU计算CRC的时间，事先计算好0至255的CRC值存入数组（不同的POLY算出来的不一样）</p><pre class=" language-bash"><code class="language-bash">static uint8 Crc_lCalculateCRC8Table<span class="token punctuation">(</span>  const uint8* const Crc_DataPtr,  const uint32 Crc_Length,  const uint8 Crc_StartValue8<span class="token punctuation">)</span>｛  uint32 LoopCounter <span class="token punctuation">;</span>  uint8 CompareData <span class="token punctuation">;</span>  uint8 StartValue8 <span class="token operator">=</span> Crc_StartValue8<span class="token punctuation">;</span>  StartValue8 <span class="token operator">=</span> StartValue8 ^ CRC_CRC8_XOR_VALUE<span class="token punctuation">;</span>  for<span class="token punctuation">(</span>LoopCounter <span class="token operator">=</span> CRC_ZERO_U<span class="token punctuation">;</span> LoopCounter <span class="token operator">&lt;</span> Crc_Length<span class="token punctuation">;</span>      LoopCounter++<span class="token punctuation">)</span>  ｛    CompareData <span class="token operator">=</span> Crc_DataPtr<span class="token punctuation">[</span>LoopCounter<span class="token punctuation">]</span> ^ StartValue8<span class="token punctuation">;</span>    StartValue8 <span class="token operator">=</span> Crc_Table8<span class="token punctuation">[</span>CompareData<span class="token punctuation">]</span> ^ <span class="token punctuation">(</span>uint8<span class="token punctuation">)</span><span class="token variable"><span class="token punctuation">((</span>uint16<span class="token punctuation">)</span><span class="token punctuation">((</span>uint16<span class="token punctuation">)</span>StartValue8 <span class="token operator">&lt;&lt;</span> CRC_BYTELENGTH_U<span class="token punctuation">))</span></span><span class="token punctuation">;</span>  ｝  StartValue8 <span class="token operator">=</span> CRC_CRC8_XOR_VALUE ^ StartValue8<span class="token punctuation">;</span>  <span class="token keyword">return</span> StartValue8<span class="token punctuation">;</span>｝</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CRC算法简介&quot;&gt;&lt;a href=&quot;#CRC算法简介&quot; class=&quot;headerlink&quot; title=&quot;CRC算法简介&quot;&gt;&lt;/a&gt;CRC算法简介&lt;/h3&gt;&lt;p&gt;循环冗余校验（Cyclic Redundancy Check， CRC）是一种根据网络数据包或计算机</summary>
      
    
    
    
    <category term="CRC" scheme="http://example.com/categories/CRC/"/>
    
    
    <category term="CRC" scheme="http://example.com/tags/CRC/"/>
    
  </entry>
  
</feed>
